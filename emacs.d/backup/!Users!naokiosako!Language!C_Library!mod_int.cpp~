#include<bits/stdc++.h>
using namespace std;

template <std::uint_fast64_t Modulus> class modint {
  using u64 = std::uint_fast64_t;

public:
  u64 a;

  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}
  constexpr u64 &value() noexcept { return a; }
  constexpr const u64 &value() const noexcept { return a; }
  constexpr modint operator+(const modint rhs) const noexcept {
    return modint(*this) += rhs;
  }
  constexpr modint operator-(const modint rhs) const noexcept {
    return modint(*this) -= rhs;
  }
  constexpr modint operator*(const modint rhs) const noexcept {
    return modint(*this) *= rhs;
  }
  constexpr modint operator/(const modint rhs) const noexcept {
    return modint(*this) /= rhs;
  }
  constexpr modint &operator+=(const modint rhs) noexcept {
    a += rhs.a;
    if (a >= Modulus) {
      a -= Modulus;
    }
    return *this;
  }
  constexpr modint &operator-=(const modint rhs) noexcept {
    if (a < rhs.a) {
      a += Modulus;
    }
    a -= rhs.a;
    return *this;
  }
  constexpr modint &operator*=(const modint rhs) noexcept {
    a = a * rhs.a % Modulus;
    return *this;
  }
  constexpr modint &operator/=(modint rhs) noexcept {
    u64 exp = Modulus - 2;
    while (exp) {
      if (exp % 2) {
        *this *= rhs;
      }
      rhs *= rhs;
      exp /= 2;
    }
    return *this;
  }
};

#include<bits/stdc++.h>
using namespace std;
 
int main(){
    using mint = modint<1000000007>;
    long long N, K, ans=0, tmp=0, tmp2=0, mod = 1e9+7;
    cin >> N >> K;
    vector<int> a(N);
    for(int i=0; i<N; i++){
	cin >> a[i];
    }
 
    for(int i=0; i<N; i++){
	for(int j=i; j<N; j++){
	    if(a[i]>a[j])
		tmp++;
	}
	for(int j=0; j<N; j++){
	    if(a[i]>a[j])
		tmp2++;		
	}
    }
    ans = (tmp*K+ ((((K-1)*K)/2)*tmp2));
    cout << ans << endl;
}


// int main() {
 

//   int n, x;
//   std::cin >> n >> x;
//   std::vector<int> s(n);
//   for (auto &e : s) {
//     std::cin >> e;
//   }
//   std::sort(s.begin(), s.end());

//   std::vector<std::vector<mint>> dp(n + 1, std::vector<mint>(x + 1));

//   for (int i = 0; i <= x; ++i) {
//     dp[0][i] = i;
//   }
//   for (int i = 0; i < n; ++i) {
//     for (int j = 0; j <= x; ++j) {
//       dp[i + 1][j] = dp[i][j] * i + dp[i][j % s[i]];
//     }
//   }

//   std::cout << dp[n][x].value() << std::endl;

//   return 0;
// }
